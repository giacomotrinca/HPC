\documentclass[11pt]{book}

\usepackage[italian]{babel}
\usepackage{graphicx}
\usepackage{verbatim}
\usepackage{fancyvrb}
\usepackage{amsthm}
\usepackage{hyperref}

%Newcommands
\newtheorem{esempio}[section]{Esempio}

\begin{document}
\title{\sc Linux per High Performance Computing}
\author{\sc Giacomo Trinca Cintioli}
\maketitle

\tableofcontents
\part{Introduzione a Linux}
\chapter{Linux - Cenni Storici}
\section{Predecessori di Linux}
\subsection{1969 - Unix}
Unix è stato un sistema operativo sviluppato nei laboratori Bell. Esso parte da un progetto preesistente, chiamato Multics\footnote{Curiosità: tale progetto nasce dalla necessità di connettere due stampanti diverse.}. Quest'ultimo fu abbandonato data la complessità e l'eccessiva difficoltà. La vera svolta fu data dall'invenzione del linguaggio C, ad opera di Thompson e Ritchie (1969-73). Questo ha permesso di portare il kernel su piattaforme diverse dal dispositivo orgiinario, costituendo di fatto il primo software della storia ad essere in grado di funzionare su più ambienti diversi. 

\subsection{1990 - POSIX Standard}
POSIX (Portable Operating System Interface for UNIX) è una famiglia di standard definiti dall'IEEE\footnote{Institute of Electrical and Electronics Engineers} il cui compito è quello di definire alcuni concetti base che vanno seguiti durante la realizzazione del sistema operativo. Esso standardizza, ad esempio, l'interfaccia di UNIX. Molti dei comandi 
di questo corso, e molte delle cose che ancora utilizziamo per costruire e/o modificare i sistemi operativi sono delle direttive standardizzate POSIX. 

\section{GNU/LINUX}
Quando parliamo di linux, generalmente, ci riferiamo al cosiddetto "Kernel Linux". Esso è la il cuore del sistema operativo, ovvero la sua parte essenziale. Con GNU (GNU's Not UNIX) ci riferiamo invece ad un set di utilities, comandi e altre componenti costruite sopra al kernel, e rimangono sempre separato da esso. Questo ci permette ad esempio un update delle librerie di compilazione separato dall'update del kernel. 
\begin{figure}
\centering
\includegraphics[width=0.8\textwidth]{img/core_gnu_linux.png}
\caption{Schema semplificato dell'interfaccia tra kernel, la libreria GNU C e le applicazioni dell'utente in un sistema operativo linux.}
\label{linux_core}
\end{figure}

\subsection{Distribuzioni Notevoli}
\begin{itemize}
	\item Red Hat Enterprise Linux (Server)\\
		Vi sono delle alternative Desktop, utilizzate spesso per testare nuove features e pacchetti prima di includerli nella versione Enterprise. Le maggiori in voga sono:
		\begin{itemize}
			\item Fedora
			\item CentOS
		\end{itemize}
	\item Debian (Desktop)\\
		Debian è un sistema operativo completamente libero, ed usa solo software e driver open source. Vi sono delle alternative, ad esempio Ubuntu, incentrata sull'utilizzo per utenti non esperit della riga di comando. Da Ubuntu sono derivate altre distribuzioni, come Mint, la quale è incentrata sulla leggerezza dell'interfaccia, oppure Kali, utilizzata per hacking e cyber security.
	\begin{itemize}
		\item Ubuntu
		\item Kali
		\item Linx Mint
	\end{itemize}
	\item Suse (Dektop / Server)\\
	L'alternativa a Red Hat per il mondo server. Come quest'ultimo, anche Suse è un sistema operativo modulare. Suse ha anche una controparte open source
	\begin{itemize}
		\item OpenSUSE
	\end{itemize}
	\item Arch Linux (Desktop)\\
	La distribuzione linux per eccellenza. Incentrata sul testing di nuove features del kernel linux e dei nuovi pacchetti. Arch Linux è il sistema operativo più malleabile e personalizzabile. Il contro è la modalità di installazione, che avviene solo tramite linea di comando. Da questa, sono derivate diverse distribuzioni, volte a ridurre la difficoltà di installazione di mantenimento. 
	\begin{itemize}
		\item Manjaro
		\item Garuda
		\item Endevour OS
	\end{itemize}
\end{itemize}

\chapter{Riga di Comando}
La riga dei comandi, o prompt dei comandi (CLI - Command Line Interface, Condole, Terminal, Shell) è la via più diretta per comunicare con il sistema operativo. I vantaggi sono:
\begin{itemize}
	\item E' semplice, ed a meno che non si commettono errori, funziona sempre.
	\item E' facile da programmare (rispetto alle applicazioni con interfaccia grafica (GUI))
	\item E' veloce nell'esecuzione dei comandi impartiti, ed efficiente nel gestire le risorse necessarie per far girare il programma.
\end{itemize}
Un altro grande vantaggio è che se il sistema operativo in qualche modo si rompe, la riga di comando è sempre accessibile (basta digitare Ctrl+Alt+F2 all'avvio del sistema operativo) attraverso quella che si chiama shell di login tty. Uno degli "svantaggi" è che bisogna conoscere i comandi. 
Ad esempio, se si vuole copiare un file in una cartella, si deve conoscere il comando di copia

\begin{verbatim}
 	cp nome_file_vecchio ~/cartella/nome_file_nuovo
\end{verbatim}
stessa cosa se si volesse creare una cartella

\begin{verbatim}
	mkdir nome_cartella
\end{verbatim}

La riga di comando può essere programmata attraverso degli script bash.\\
E' importante sapere sempre dove ci trova nella shell, o meglio sapere qual è la nostra \textit{working directory}. Dobbiamo anche sapere quali comandi verranno stoppati se chiudiamo la nostra shell.

\subsection{Elementi della shell}
Una volta aperta la shell \verb"tty"
, o un emulatore del terminale in linux, il prompt dei comandi si presenta nella forma:

\begin{verbatim}
	[username@login_shell ~] $
\end{verbatim}

dove lo user name è il nome dell'utente che ha effettuato il login sulla shell, e \verb"login_shell" è il nome con il quale il personal computer viene identificato nella rete locale, anche detto host name. Il simbolo \verb"~" identifica la \verb"home directory", che si trova in \verb"/home/nome_utente/home/". Per convenzione si utilizza il simbolo \verb"$" per identificare un utente standard, mentre \verb"#" per identificare un utente con privilegi di root. Un utente con privilegi di root può scrivere nelle cartelle diverse dalla home directory.\\
La struttura tipica di un comando \verb"bash" è la seguente
\begin{verbatim}
	[username@login_shell ~] $ hostname -f
\end{verbatim}
per eseguire il comando basta premere \verb"Enter" sulla tastiera. Tale comando stampa su schermo il nome del computer, l'output sarà dunque
\begin{verbatim}
	login_shell
\end{verbatim}
vediamo che accanto al comando \verb"hostname" viene aggiunta un'opzione \verb"-f". I comandi hanno tutti differenti opzioni, le quali possono essere stampate con l'ausilio del comando \verb"man", oppure aggiungendo l'opzione \verb"--help".\\
Una volta che il comando è stato eseguito, sarà di nuovo visibile il prompt di \verb"bash", dove sarà possibile digitare un nuovo comando. Finché non è stato eseguito un comando, non sarà possibile eseguire nessun altro comando, a meno che non si apra una nuova shell.\\
Possiamo navigare nella storia dei comandi della nostra shell utilizzando le frecce della tastiera, senza dover riscrivere il comando da capo. Se dobbiamo quindi eseguire più volte lo stesso comando possiamo cercarlo nella nostra \verb"bash_history".\\
Il tasto \verb"Tab" serve per l'autocompletamento (Tab completation) dei comandi. Se vogliamo che funzioni, dobbiamo scrivere abbastanza lettere per far si che il sistema operativo trovi il comando, che, come vedremo più in là sarà collegato ad un file binario all'interno di \verb"/usr/bin" o \verb"/usr/sbin". Premendo una seconda volta \verb"Tab" è possibile vedere una lista di comandi compatibili con le lettere già digitate nel prompt di \verb"bash". \\
L'ultima combinazione di tasti notevole è \verb"Ctrl-C", la quale ferma il comando che è attualmente in esecuzione. Questo fa si che il comando in esecuzione venga fermato con un messaggio di errore, spesso identificato come \verb"Keyboard Abort". \\
La riga di comando è sempre \textit{case sensitive}, ovvero fa differenza tra caratteri maiuscoli e minuscoli. Molto spesso le opzioni dei comandi possono essere scritte in più modi. Possiamo ad esempio scrivere
\begin{verbatim}
	sbatch --time 0:30:00
\end{verbatim}
oppure 
\begin{verbatim}
	sbatch -t 0:30:00
\end{verbatim}
questi due comandi sono identici. Il primo viene detto "full name command", mentre il secondo viene chiamato "shorthand command".\\
Uno svantaggio per gli utenti poco esperti della riga di comando è l'assenza totale del tasto \verb"Annulla". Ovvero, una volta mandato in esecuzione un comando non si può tornare indietro. Conseguentemente non vi saranno finestre di dialogo che chiedono se si è sicuri di voler procedere. Ad esempio, se vogliamo eliminare un file utilizzando il comando \verb"rm" la shell non ci chiederà se siamo sicuri di volerlo fare, e procederà con l'esecuzione del comando.\\
Questo potrebbe causare, nell'eventualità di utenti con permessi di root, gravi problemi se si eliminano o modificano files necessari al sistema operativo, ad esempio come\footnote{Mai mandare in esecuzione questo comando!}
\begin{verbatim}
 sudo rm -rf /
\end{verbatim}
Morale: mai mandare in esecuzione un comando se non si sa cosa esso faccia esattamente. 

\chapter{Struttura delle Cartelle in Linux}
\section{Struttura ad albero - Filesystem Tree}
Diversamente dai sistemi Windows, dove i volumi montati nel sistema (sia interni che esterni) sono etichettati da lettere (come ad esempio \verb"C:/"), su Linux esiste una sola root directory \verb"/". Il livello più alto di questo albero di cartelle è uguale in tutti i sistemi linux, ovvero è standardizzato. I volumi esterni e interni vengono montati in delle cartelle (spesso \verb"/mnt"), chiamati mounting points, ovvero punti di montaggio. Il percorso di un file può essere identificato in modo assoluto, ad esempio 
\begin{verbatim}
/home/nome_utente/Documenti/documento.pdf
\end{verbatim}
oppure in modo relativo sapendo quel è la working directory della nostra shell. Per sapere qual è la working directory si usa il comando \verb"pwd".

\begin{figure}
	\centering
	\includegraphics[width=0.8\textwidth]{img/filesystem_tree.png}
	\caption{Tipica struttura ad albero di un sistema Linux.}
	\label{fs_tree}
\end{figure}

Come vediamo nella Figura \ref{fs_tree} vi sono molte cartelle, che riassumiamo qui:
\begin{itemize}
	\item \verb"/": è la cartella di livello più alto, la quale contiene tutte le altre cartelle.
	\item \verb"bin/": qui vi sono tutti i programmi (come le shells, ad esempio)
	\item \verb"etc/": qui vi sono tutti i files di configurazione 
	\item \verb"home/": qui è dove l'utente spende la maggior parte del tempo. Vi sono tutti i files personali dell'utente, ed è l'unica cartella dove un utente non root può scrivere. Molte distribuzioni linux, tra le quali OpenSUSE, crea una partizione dedicata per questa cartella per aumentare la stabilità e la sicurezza del sistema. In questa cartella vi è una sottocartella per ogni utente del sistema.
	\item \verb"opt/": in questa cartella ci sono i programmi opzionali. Come vedremo, ad esempio in questa cartella potranno essere caricati driver opzionali (ad esempio quelli della scheda grafica, bluetooth, etc.) 
	\item \verb"tmp/": contiene i files temporanei utili ai programmi per poter girare. Ad esempio un estrattore di archivi zip può utilizzare questa cartella per contenere l'archivio da estrarre. 
	\item \verb"usr/": acronimo di "unix system resources", dove vi sono ancora altri programmi e librerie.
	\item \verb"var/": contiene dei files che cambiano nel tempo (variable files) come ad esempio i file di log, che possono essere consultati in caso di errore di esecuzione di qualche comando o programma.
\end{itemize}

Ogni cosa in linux è rappresentato sottoforma di file, molto spesso sotto forma di file di testo. Ad esempio, la configurazione di una shell grafica (ad esempio i3, gnome, kde) può essere configurata a partire da un file di configurazione senza passare per l'applicazione grafica che permette di personalizzare le impostazioni grafiche. Nel filesystem tree vi sono anche altre cartelle, il quale nome può variare a seconda della distribuzione. Ad esempio nella cartella \verb"/dev/" ci sono i files relativi ai dispositivi collegati alla scheda madre (ad esempio hard disks, pendirves, lettori DVD) mentre nella cartella \verb"/proc/" vi sono tutti i files relativi alle informazioni del sistema operativo.

Ogni comando che viene scritto nel prompt di bash è un programma o uno script, che giace in una cartella del filesystem. Per scoprire dove risiede tale programma o script basta scrivere
\begin{verbatim}
	which <comando>
\end{verbatim}
che darà come output
\begin{verbatim}
	/cartella/.../<comando>
\end{verbatim}
ad esempio se apriamo un shell bash e digitiamo il comando \verb"firefox", l'hostname command \verb"firefox" punterà al programma Firefox che aprirà una finestra con il browser internet. Vediamo alcune abbreviazioni per le cartelle nella shell di bash:
\begin{itemize}
	\item \verb"." indica la cartella corrente (working directory)
	\item \verb".." indica la cartella padre della cartella in cui siamo 
	\item \verb"~" indica la cartella \verb"/home/nome_utente/".
\end{itemize}

Per navigare nel filesystem si usa il comando \verb"cd", che sta per change directory, che è parte dello standard POSIX, ovvero è presente in tutti i sistemi linux / unix. Ad esempio con 
\begin{verbatim}
	cd ..
\end{verbatim}
ci spostiamo nella cartella padre della nostra attuale working directory. Notiamo che dopo il comando \verb"cd" vi è uno spazio, che delimita il comando dal suo argomento \verb".." ovvero la cartella di destinazione.\\
Un altro comando fondamentale è \verb"ls". Esso ci dice quali files giacciono in una specifica cartella. La sintassi è la seguente
\begin{verbatim}
	ls [OPTIONS] /percorso_cartella
\end{verbatim}
le opzioni di \verb"ls" sono molteplici. Le più importanti sono
\begin{itemize}
	\item \verb"-l" la quale ci fornisce più informazioni per i files all'interno della cartella. E' così comune che ha un suo link, ovvero un comando dedicato \verb"ll" = \verb"ls -l"
	\item \verb"-a" che ci fa vedere anche i files nascosti (i quali iniziano con un punto)
	\item \verb"-t" che ordina i files per data di modifica.
\end{itemize}


\subsection{Gestione dei Files}
Come prima cosa diciamo che negli ambienti Linux l'estensione del file non importa. L'estensione viene utilizzata per facilitare la lettura da parte degli utenti. Qualche programma potrebbe cercare l'estensione dei file, ma sono casi rari. Ciò che importa al sistema è se un file sia di testo o meno. Esempi di file di testo sono
\begin{itemize}
	\item File di configurazione
	\item Scripts e programmi (\verb".sh", \verb".c", \verb".cpp", \verb".p")
	\item File di informazione del sistema
\end{itemize}
L'altra grande categoria di files sono i files binari. Questi non possono essere cercati ne letti (ad esempio con il comando \verb"cat" o \verb"more"). Ci viene in aiuto il comando \verb"file", il quale ci indica il tipo di file. \\
Ad esempio, se abbiamo un file di testo che abbiamo denominato \verb"test.jpeg" e digitiamo
\begin{verbatim}
	file test.jpeg
\end{verbatim}
l'output sarà
\begin{verbatim}
	test.jpeg: ASCII text
\end{verbatim}
ovvero il file \verb"test.jpeg" è un file di testo codificato con codice \verb"ASCII". Per un'immagine vera, l'output sarà diverso, ad esempio:
\begin{verbatim}
	JPEG image data, Exif standard: [TIFF image data, little-endian, 
\end{verbatim}
\begin{verbatim}
	direntries=0], baseline, precision 8, 3840x2160, components 3
\end{verbatim}

Molti dei comandi che manipolano i files, funzionano anche per le cartelle, delle volte basta aggiungere l'opzione \verb"-r" che sta per \verb"--recursive". Nei casi più semplici, come ad esempio il comando \verb"mv" che sposta/rinomina i files e le cartelle non è necessario aggiungere l'opzione \verb"-r". 
\begin{verbatim}
	mv <vecchio_nome> <nuovo_nome>
\end{verbatim}

Un altro comando fondamentale è quello utilizzato per copiare i files
\begin{verbatim}
	cp <vecchio_nome> <nuovo_nome>
\end{verbatim}
Se vogliamo copiare un'intera cartella basta aggiungere l'opzione \verb"-r":
\begin{verbatim}
	cp -r <vecchia_cartella> <nuova_cartella>
\end{verbatim}

Per creare un file vuoto si utilizza il comando \verb"touch":
\begin{verbatim}
	touch nome_file
\end{verbatim}
questo viene utilizzato anche per accedere al file e modificare dunque la data di accesso ad un file. \\
D'altra parte esiste anche un comando utilizzato per rimuovere un file o una cartella. 
\begin{verbatim}
	rm <nome_file>
	rm -r <nome_cartella>
\end{verbatim}

E' possibile utilizzare anche l'opzione \verb"-f" che sta per \verb"--force", che fa sì che la shell non ci chieda ogni volta se siamo sicuri di eliminare il suddetto file. \\
Tutti questi comandi funzionano con un solo file. Possiamo passare come argomenti più files, oppure
\begin{itemize}
	\item Globbing \verb"?" per il numero di caratteri che mancano. Ad esempio se abbiamo dei files nella nostra cartella
	\begin{verbatim}
		file1.txt file2.txt file3.txt file4.txt file11.txt
	\end{verbatim}
	e digitiamo 
	\begin{verbatim}
		rm file?.txt
	\end{verbatim}
	esso rimuoverà tutti i files tranne \verb"file11.txt".
	\item Globbing \verb"*". Digitando invece
	\begin{verbatim}
		rm file*.txt
	\end{verbatim}
	verranno rimossi tutti i files.
	\item Globbin \verb"[]". Digitando 
	\begin{verbatim}
		rm file[1-3].txt
	\end{verbatim}
	verranno rimossi tutti i files tranne \verb"file4.txt" e \verb"file11.txt".
\end{itemize}

Se vogliamo cercare un file possiamo utilizzare il comando \verb"find". Ad esempio digitando 
\begin{verbatim}
	find . -name "file1.txt" -type f
\end{verbatim}
cerchiamo un file nella cartella \verb".", ovvero la nostra working directory denominato \verb"file1.txt" di tipo \verb"f" ovvero file. Se cerchiamo una directory l'opzione da aggiungere sarà \verb"-type d".\\
Possiamo scegliere tante opzione, le quali rendono questo comando molto potente. Possiamo ad esempio cercare dei file che sono stati modificato solo dopo un certo tempo, oppure eseguire un comando per ogni file che viene trovato (opzione \verb"-exec"). Le wildcards, ovvero i caratteri \verb"? * []" introducono dei problemi nella shell. Infatti, può capitare che passando un argomento come ad esempio \verb"file*.txt" si raggiunga il limite massimo degli argomenti passabili al comando. Questo succede perché la shell prima crea una lista di argomenti con tutti i possibili nomi associati a \verb"file*.txt" e poi li passa come argomento al comando. Per ovviare a questo problema, ad esempio nel comando \verb"find" si può utilizzare l'identificatore di stringa (\verb""""):
\begin{verbatim}
	find . -type f -name "file*.txt"
\end{verbatim}
in questo modo non è la shell che crea la lista di argomenti, ma se ne occupa il comando \verb"find". 

\section{Canali I/O}
La shell bash ha fondamentalmente tre modi per comunicare con l'utente:
\begin{itemize}
	\item Standard input (\verb"stdin"): cosa scriviamo nel prompt della shell
	\item Standard output (\verb"stdout"): output normale della shell
	\item Standard error (\verb"stderr"): output di errore della shell
\end{itemize}
E' molto comodo separare i canali di output. Un canale, o stream, è un deposito di memoria dal quale escono i dati di output (che andranno nei due canali di output \verb"stdout" e \verb"stderr", e riceve dati dal canale di input \verb"stdin"). 

Lo standard input è un canale da cui giunge un flusso di dati (spesso testuali) in ingresso ad un programma. Il programma li trasferisce effettuando operazioni di lettura. Non tutti i programmi necessitano di dati in input: ad esempio i comandi ls o dir (che mostrano il contenuto delle directory) svolgono il loro compito senza bisogno di leggere dati in input.
Il flusso di input, salvo casi di redirezione\footnote{Deviazione dei canali standard (standard input, standard output e standard error) di un dato comando verso destinazioni (o da sorgenti, nel caso dello standard input) che sono diverse da quelle predefinite.}, proviene dal terminale (es. dall'utente tramite tastiera) da cui il programma è stato avviato. 

Lo standard output è il canale su cui un programma scrive i suoi dati in output. Il programma trasferisce i dati effettuando operazioni di scrittura. Non tutti i programmi producono output: ad esempio il comando mv (che cambia il nome di un file o di una directory) normalmente non produce dati in output.
Il flusso di output, salvo casi di redirezione, è diretto al terminale da cui il programma è stato avviato (es. a monitor o console a favore dell'utente). 

\begin{figure}
	\centering
	\includegraphics[width=0.8\textwidth]{img/streams.png}
	\caption{Schematizzazione semplificata di un canale.}
	\label{fig:streams}
\end{figure}

Lo standard error è un altro canale di output, tipicamente usato dai programmi per i messaggi d'errore o di diagnostica. Esso è un canale indipendente dallo standard output, e se ne può effettuare la redirezione separatamente dagli altri. La sua destinazione è solitamente il terminale da cui il programma è stato avviato, in modo da rendere massime le possibilità di essere visto anche quando lo standard output è diretto altrove: ad esempio, nel caso di una pipeline software, l'output di un programma è fornito come input al programma successivo, ma i suoi messaggi d'errore sono ancora visualizzati sul terminale.
È accettabile e normale che lo standard output e lo standard error abbiano la stessa destinazione, come nel caso del terminale testuale: i messaggi compaiono nello stesso ordine in cui il programma li scrive, salvo quando sono in uso dei buffer (ad esempio quando lo standard error non ha buffer e lo standard output ha un buffer di linea: in questo caso i dati scritti sullo standard error in un secondo momento possono apparire prima dei dati scritti su standard output in un primo momento, in quanto il buffer dello standard output potrebbe non essere ancora stato riempito). 

Come vediamo in Figura \ref{fig:streams} l'input e l'output possono talvolta sovrapporsi, e non ci sono regole che gestiscono l'ordine in cui avvengono l'input e l'output. 

Possiamo inoltre redirezionare l'input e output ad altre sorgenti. Possiamo ad esempio redirezionare l'input di un comando e prenderlo dall'output di un altro comando, oppure possiamo redirezionare l'output in uno stream su file con la sintassi:
\begin{verbatim}
	comando > file
\end{verbatim} 

Con il simbolo \verb">" possiamo infatti redirezionare lo \verb"stdout" su un file denominato \verb"file". Per redirezionare lo \verb"stdout" si usa la sintassi

\begin{verbatim}
	comando 2> file
\end{verbatim}

mentre se vogliamo dare in input ad un comando un file, e quindi redirezionare lo \verb"stdin" si usa
\begin{verbatim}
	comando < file
\end{verbatim}

Possiamo poi, come già detto, utilizzare l'output di un comando (\verb"comando2") come input di un altro comando (\verb"comando1") utilizzando il simbolo pipe \verb"|":
\begin{verbatim}
	comando1 | comando2
\end{verbatim}

Potremmo aver bisogno di appendere output di più comandi sullo stesso file senza sovrascriverlo ogni volta. Per fare questo si utilizza il simbolo \verb">>":
\begin{verbatim}
	comando >> file
\end{verbatim}

Nei sistemi Linux, i canali I/O standards sono numerati seguendo la convenzione del linguaggio C. \begin{verbatim}
	0: stdin
	1: stdout
	2: stderr
\end{verbatim}
Potremmo voler redirezionare lo \verb"stdout" di un programma in un file diverso dal canale \verb"stderr". 
\begin{verbatim}
	comando > output.log 2> error.log
\end{verbatim}
Con questa sintassi si redireziona lo standard output nel file \verb"output.log" mentre lo standard error in \verb"error.log". Possiamo inoltre redirezionare entrambi i canali sullo stesso file con la sintassi

\begin{verbatim}
	comando 2>&1 > output_error.log
\end{verbatim}

\subsection{Visualizzazione e Ricerca}
Vediamo ora alcuni comandi per la visualizzazione del contenuto di un file di testo sulla console bash. Per visualizzare il contenuto di un file esistono diversi modi. Il più semplice è l'utilizzo del comando \verb"cat". Con il comando \verb"less" inoltre possiamo scorrere il testo (ad esempio il comando \verb"man" usa questo comando per visualizzare il file di testo nel quale vengono spiegati i vari utilizzi dei programmi). Altri comandi, come ad esempio \verb"head" o \verb"tail" stampano in \verb"stdout" le prime righe o le ultime di un file.\\
Il comando \verb"grep" viene utilizzato per la ricerca di contenuti nei file di testo. La sintassi è
\begin{verbatim}
	grep [OPZIONI] [stringa da cercare] [nome del file]
\end{verbatim} 
ad esempio

\begin{verbatim}
	grep -i -r "test" example*.txt
\end{verbatim}
le opzioni più comuni sono
\begin{verbatim}
	-r: ricerca ricorsiva
	-i: ignora maiuscole e minuscole
	-I: ignora i file di tipo binario
\end{verbatim}

Questo comando è molto utile quando ci ritroviamo con dei files di grandi dimensioni e vogliamo cercare una specifica stringa all'interno di esso. Come il comando \verb"find", a causa delle wildcards e la moltitudine di opzioni, è molto potente. \\
Possiamo utilizzare il comando \verb"grep" combinandolo con il comando \verb"ll" (ovvero \verb"ls -l") usufruendo del simbolo pipe \verb"|" con questa sintassi:
\begin{verbatim}
	ll | grep -i test
\end{verbatim}
questo comando fa vedere tutti i files che hanno al loro interno una stringa \verb"test".

\chapter{Utenti e Processi}
Come ogni sistema operativo moderno, anche Linux è un sistema multiutente. Questo vuol dire che il login nel sistema operativo può essere effettuato da più utenti. Esistono fondamentalmente due tipologie di utente: standard o amministratore. Ogni utente, nei sistemi Linux possiede una cartella \verb"home" dedicata. \\

\section{Permessi}
L'accesso ai files di sistema viene regolamentato attraverso dei \verb"permessi" specifici per ogni utente. Solo l'utente \verb"root" può fare qualsiasi cosa all'interno del sistema operativo. Ad esempio ad un utente standard potrebbe essere persino impedito di leggere in alcune cartelle. Questi permessi possono essere configurati solo dagli utenti amministratori. \\
Ogni file ed ogni cartella ha specifici permessi. Tali regole specificano cosa può fare o non fare con quel file o quella cartella\footnote{"Non puoi rompere ciò che non vedi".}.\\
Gli utenti standard, nel caso in cui conoscano la \verb"password" dell'amministratore, possono ottenere i permessi di \verb"root" e lanciare programmi o comandi con tali permessi digitando
\begin{verbatim}
	sudo <comando>
\end{verbatim}

Ogni utente appartiene a uno o più gruppi. Non appena viene creato, un utente appartiene ad un gruppo primario. Anche in base a quest'appartenenza si possono configurare i permessi per i files e cartelle. Esistono tre tipi di permessi:
\begin{itemize}
	\item Lettura (\verb"r"): chi può vedere il contenuto di files e cartelle
	\item Scrittura (\verb"w"): chi può cambiare il contenuto di files e cartelle
	\item Esecuzione (\verb"x"): chi può eseguire un file (ad esempio uno script bash \verb".sh")
\end{itemize}

Questi tre tipi di permessi di files non sono indipendenti. Ovviamente per poter modificare un file deve essere necessario vederli. Quindi in molti casi, se non tutti, il permesso di scrittura include quello di lettura. E' possibile però poter eseguire uno script senza essere in grado di leggere il suo contenuto. \\
Per poter vedere chi ha il permesso su un file, chi lo ha creato, e quali permessi hanno i gruppi, etc. si utilizza il comando \verb"ll".

\begin{figure}
	\centering
	\includegraphics[width=0.8\textwidth]{img/permessi.png}
	\caption{Output del comando ll.}
	\label{llcommand}
\end{figure}

Vediamo più in dettaglio l'output introdotto in Figura\ref{llcommand}
\begin{verbatim}
	drwxr-xr-x 2 user groups size data_ultima_modifica nome_file
	-rw-r--r-- 1 user groups size data_ultima_modifica nome_file
\end{verbatim}
la prima lettera (prima riga \verb"d", seconda riga \verb"-") indica il tipo di file. 
\begin{verbatim}
	d: directory
	f: file
	-: not set
	l: link
\end{verbatim}
poi abbiamo tre sequenze di \verb"rwx". La prima di queste ci indica i permessi che possiede l'utente \verb"user" sul file o cartella. La seconda sequenza indica i permessi dei gruppi \verb"groups" che possiedono il file. La terza sequenza indica quali permessi degli utenti di altri gruppi che non possiedono il file. Nella seconda riga vediamo che alcuni permessi non ci sono. Quando un utente o un gruppo non ha un permesso, esso viene visualizzato con il simbolo \verb"-".
\subsection{Cambiare i permessi}
Esistono dei comandi volti a cambiare i permessi di files/cartelle, e la modifica del possessore di quest'ultimi. Con il comando \verb"chown" si può cambiare il possessore di un file. Esso necessita di permetti di \verb"root":
\begin{verbatim}
	sudo chown <nuovo_possessore> <nome_file>
	sudo chown <nuovo_possessore>:<nuovo_gruppo> <nome_file>
\end{verbatim}

Per cambiare i permessi di un file, possiamo utilizzare il comando \verb"chmod" con la seguente sintassi di esempio:
\begin{verbatim}
	chmod u+x <nome_file>
\end{verbatim}
dobbiamo quindi specificare tre opzioni. La prima specifica per "chi" cambiare il permesso, ed abbiamo quattro possibilità
\begin{verbatim}
	u: user
	g: group
	o: others
	a: all
\end{verbatim}
La seconda opzione specifica se aggiungere (\verb"+") o togliere (\verb"-") il permesso, mentre la terza deve specificare quale permesso \verb"r", \verb"w", oppure \verb"x".

\section{Gestione dei Processi}
In Linux, un file eseguibile memorizzato su disco costituisce un programma. Quando un programma viene lanciato e caricato in memoria viene chiamato processo. Con linguaggio tecnico possiamo definire il processo come l'istanza di un programma.\\
I processi hanno un ciclo vitale simile a quello degli organismi viventi: nasce (il programma viene lanciato), vive (il programma è in esecuzione) e muore (il programma viene terminato).\\
Esistono tre tipi di processi:
\begin{itemize}
	\item Processi di sistema (\verb"system"), anche detti demoni (\verb"daemons")
	\item Processi dell'utente (\verb"user")
	\item Processi dell'utente manuali (\verb"user manually launched")
\end{itemize}

I primi sono i processi necessari al sistema operativo per essere in esecuzione (ad esempio il processo che gestisce un driver). La seconda tipologia indica i processi dell'utente necessari per l'avvio di altri processi (ad esempio il gestore delle finestre, o window manager (\verb"wm"))
Possiamo visualizzare sulla shell di bash i processi attualmente in esecuzione con il comando \verb"top". Altri comandi danno delle specifiche differenti sui processi, come ad esempio \verb"pstree", il quale ci indica l'albero delle dipendenze dei processi. Ad esempio, lanciando il browser web \verb"firefox", esso ha bisogno che sia attivo il processo che gestisce le finestre, in quanto \verb"firefox" è un browser web grafico. \\

\begin{figure}
	\centering
	\includegraphics[width=0.8\textwidth]{img/top.png}
	\caption{Tipico output del comando top.}
	\label{top_out}
\end{figure}
Come per i file e le cartelle, anche i processi hanno un possessore. Solo il possessore del processo può cambiarne lo stato. Ad esempio, sapendo che il gestore delle finestre è posseduto dall'utente \verb"root", solo chi conosce la password di \verb"root" può lanciare o chiudere il gestore. In generale vale la regola che un processo può fare solo quello che il suo possessore può fare. Ad esempio un programma, che lanciato diventa un processo, non può scrivere in una cartella in cui il possessore del processo non ha il permesso di scrittura.\\
Quando viene avviato un processo gli viene assegnato un numero univoco chiamato ID processo (\verb"PID") che lo identifica in modo univoco nel sistema.
Il \verb"PID" non è modificabile e non varia per tutta la durata del processo. Solitamente il valore di \verb"PID" viene assegnato in modo sequenziale: un nuovo processo, quindi, assumerà un valore di \verb"PID" maggiore di uno rispetto all'ultimo processo creato.\\
Conoscendo il \verb"PID" è possibile agire sul processo, ad esempio terminandolo.
Il programma \verb"top" ha diversi comandi
\begin{itemize}
	\item \verb*|u|: filtra i processi in base all'utente che li possiede
	\item \verb*|k|: uccide uno specifico processo
	\item \verb*|h|: mostra i comandi (identico a \verb*|--help|)
	\item \verb*|f|: gestisce le colonne mostrate da \verb*|top|
	\item \verb*|x|: sottolinea e ordina secondo una colonna
	\item \verb*|<>|: sceglie la colonna secondo la quale ordinare i processi
	\item \verb*|R|: inverte l'ordine della colonna selezionata
	\item \verb*|q|: esce da \verb*|top|
\end{itemize}

Abbiamo già visto che un comando lanciato dalla shell diventa un processo. Lanciando solamente il programma, esso verrà eseguito nella shell, e terrà la shell occupata fino alla fine dell'esecuzione dello stesso. Digitando invece
\begin{verbatim}
	<comando> &
\end{verbatim}
esso verrà eseguito in background. Questa sintassi ci è utile se il programma viene eseguito su una finestra. In questo modo, infatti, la shell continuerà ad essere utilizzabile. \\
Possiamo sospendere un comando che è stato mandato nella shell utilizzando la combinazione da tastiera \verb*|Ctrl+z|. Un comando che è stato messo in pausa può essere mandato in background utilizzando il comando \verb*|bg|. Possiamo inoltre riportare nella shell un comando che è stato messo in background con il comando \verb*|fg|, con la sintassi
\begin{verbatim}
	fg <job-ID>
\end{verbatim}
dove il \verb*|job-ID| è diverso dal \verb*|PID|, e può essere visualizzato con il comando \verb*|jobs|.

\chapter{Strumenti e Utilities}

\section{L'editor di testo VIM}
L'editor di testo predefinito di Linux si chiama \verb*|vi|. Questo ha anche una versione migliorata: \verb*|vim| (\verb*|vi| improved). Esso è un editor da console, ovvero non viene lanciata una finestra grafica, ma il file viene editato direttamente all'interno della shell bash.\\
Tra i vantaggi troviamo
\begin{itemize}
	\item Sempre disponibile, in tutti i sistemi Linux 
	\item A patto di conoscerne i comandi, è molto efficiente e veloce.
\end{itemize}
Mentre abbiamo lo svantaggio di avere un interfaccia utente molto poco intuitiva, e la mole di comandi disponibili è eccessiva. 

\begin{figure}
	\centering
	\includegraphics[width=0.8\textwidth]{img/vim_modes.png}
	\caption{Schema di comandi per cambiare la modalità di vim.}
	\label{vim_modes}
\end{figure}
Da \verb*|vi| mantiene la caratteristica di essere modale, ovvero di avere modalità diverse nelle quali i normali caratteri della tastiera hanno significato di inserimento testo o di comandi. In questo modo, è possibile usarlo senza far uso del mouse, né dei tasti meta, permettendo una velocità maggiore di scrittura, a prezzo di maggiore difficoltà di utilizzo da parte di nuovi utenti. Vediamo qui di seguito alcuni dei comandi più comuni. Per aprire un file vuoto si utilizza il comando \verb*|vim|, mentre per aprire un file con uno specifico nome
\begin{verbatim}
	vim <nome_file>
\end{verbatim}
 I comandi più comuni sono:
 \begin{itemize}
 	\item Gestione file:
 		\begin{itemize}
 			\item \verb*|:w| per salvare il file (\verb*|write|)
 			\item \verb*|:w <nome_file>| per salvare il file con nome \verb*|<nome_file>|
 			\item \verb*|:wq|, \verb*|:x|, \verb*|ZZ| per salvare e chiudere
 			\item \verb*|:q!| per chiudere il file senza salvare.
 		\end{itemize}
 	\item Muoversi all'interno del file:
 		\begin{itemize}
 			\item \verb*|frecce| per muovere il cursore nella direzione della freccia
 			\item \verb*|h,j,k,l| per muovere il cursore a sinistra, giù, su, destra
 			\item \verb*|$| per muovere il cursore alla fine del file
 			\item \verb*|gg| per muovere il cursore alla prima riga
 			\item \verb*|G| per muovere il cursore all'ultima riga
 			\item \verb*|w| per saltare alla parola successiva
 			\item \verb*|b| per saltare alla parola precedente
 			\item \verb*|%| per saltare al carattere corrispondente, ad esempio \verb*|(...),[...],{...}|
 		\end{itemize}
 	\item Modifica del testo:
 		\begin{itemize}
 			\item \verb*|u|: annulla l'ultima modifica
 			\item \verb*|Ctrl + r|: rifai l'ultima modifica
 			\item \verb*|.|: ripeti l'ultimo comando
 			\item \verb*|x|: cancella carattere
 			\item \verb*|dd|: elimina l'intera riga
 			\item \verb*|yy| o \verb*|Y|: copia l'intera riga
 			\item \verb*|p|: incolla contenuto dopo il cursore
 		\end{itemize}
 	\item Ricerca:
 		\begin{itemize}
 			\item \verb*|/pattern|: vai avanti nella ricerca per espressioni regolari
 			\item \verb*|?pattern|: vai indietro nella ricerca espressioni regolari
 			\item \verb*|n|: ripeti l'ultima ricerca
 			\item \verb*|N|: ripeti l'ultima ricerca nella direzione opposta
 			\item \verb*|%s/old/new/|: sostituisce \verb*|old| con \verb*|new| nella riga corrente
 			\item \verb*|%s/old/new/g|: sostituisce \verb*|old| con \verb*|new| nell'intero file		
 		\end{itemize}
 \end{itemize}


\section{Shell Scripts}
Una volta che sappiamo come interagire con la la shell di Linux, sappiamo anche dare una serie di istruzioni, e salvare queste in un file eseguibile. Questi sono detti \textit{scripts}. Questo file di testo viene dato in input nel terminale, ed esso eseguirà tutte le istruzioni contenute al suo interno. Il vantaggio di questo metodo di scripting è ovviamente l'automazione di alcune operazioni che viene fatta molto semplicemente scrivendo le istruzioni. Lo svantaggio, se così si può dire, è che non sappiamo della presenza di errori fino al momento in cui lo script non viene lanciato nel terminale. \\
Per eseguire uno script \verb*|.sh| basta scrivere nel terminale:
\begin{verbatim}
	./script.sh
\end{verbatim}
avendo cura che l'utente abbia il permesso di eseguire il file nella shell.\\
Come vediamo dalla sintassi, dobbiamo specificare in che cartella si trova il nostro script, infatti nel nostro caso abbiamo identificato la working directory con \verb*|./|. Questo perché Linux cerca i comandi nella cartella in cui siamo, al massimo nelle directories incluse nella variabile di ambiente della \verb*|$PATH|\footnote{Approfondiremo il concetto e gli utilizzi delle variabili d'ambiente successivamente.} per questioni di sicurezza. Vediamo un primo esempio di script bash.
\begin{esempio}
	\begin{verbatim}
		\\
		1 #!/bin/bash
		2
		3 #Questo è un commento
		4 echo "Hello World"
		5
		6 ls -l
		7 sleep 3s
		8 ls \
		9  -l
	\end{verbatim}
\end{esempio}

Nella riga \verb*|1| viene specificato l'interprete di \verb*|bash|. Questa direttiva deve trovarsi sempre nella prima riga di ogni script. Esso si specifica con il carattere utilizzato per i commenti, \verb*|#| seguito dal punto esclamativo \verb*|!|. Vediamo che alla riga \verb*|8| c'è il simbolo \verb*|\|. Esso specifica che il comando continua a capo. \\
Durante l'esecuzione degli script verrà stampato sulla console l'output di tutti i comandi. Utilizzando le redirezioni possiamo, ovviamente, stampare su file tali output. \\
Possiamo assegnare un valore ad una variabile tramite l'operazione binaria \verb*|=|. 
\begin{verbatim}
	var="valore"
\end{verbatim}
dove notiamo che ai lati del simbolo \verb*|=| non vi sono spazi. I simboli \verb*|"..."| servono quando nel valore vi sono degli spazi o dei caratteri speciali. \\
Possiamo stampare il valore di \verb*|var| con
\begin{verbatim}
	echo $var
\end{verbatim}	
Un errore comune che viene commesso durante l'assegnazione delle variabili è confondere il ruolo delle doppie virgolette e quello delle singole virgolette.\\
Utilizzando le singole virgolette verrà assegnata alla variabile il contenuto esatto. Ad esempio scrivendo:
\begin{verbatim}
	var='$ciao'
\end{verbatim}
nella variabile \verb*|var| ci sarà la stringa \verb*|$ciao|, mentre usando
\begin{verbatim}
	var1='ciao'
	var2="$var1"
\end{verbatim}
nella variabile \verb*|var2| ci sarà il valore effettivo di \verb*|var1|, che è in questo caso la stringa \verb*|ciao|. Se racchiudiamo tra parentesi un comando, esso verrà primo eseguito. Ad esempio digitando
\begin{verbatim}
	var=$(bla)
\end{verbatim}
verrà prima eseguito il comando \verb*|bla| e il suo output verrà memorizzato nella variabile \verb*|var|.\\
Possiamo passare degli argomenti quando eseguiamo lo script dal terminale. Ad esempio digitando:
\begin{verbatim}
	./script.sh -f 5.0
\end{verbatim}
nello script avremo le seguenti variabili assegnate
\begin{verbatim}
	$0=script.sh
	$1=-f
	$2=5.0
\end{verbatim}
Possiamo inoltre usufruire dei ciclo e degli statements \verb*|if|
\begin{esempio}
	\begin{verbatim}
		#!/bin/bash
		for file in $( ls ); do
			echo item: $file
		done
		
		if[ -e $filename ]; then
			echo "$filename exists."
		fi
	\end{verbatim}
\end{esempio}



\chapter{Variabili di Ambiente}
Le variabili d'ambiente, nei sistemi Unix-like, e più in generale negli ambienti \verb*|POSIX| sono delle variabili specifiche per ogni processo. Ogni processo possiede il proprio insieme di variabili d'ambiente distinto e separato da quello degli altri processi, ed in nessun caso un processo può modificare le variabili d'ambiente di un altro processo; esse tuttavia si propagano, duplicandosi, di processo padre in processo figlio. \\
Le variabili d'ambiente hanno un ruolo tradizionalmente significativo nella configurazione dei programmi: esse sono usate ad esempio per specificare le impostazioni di localizzazione, o per indicare ad un programma le directory ove reperire le proprie risorse, o ancora per modificarne il comportamento predefinito. \\
\section{Caratteristiche}
Possiamo assegnare una variabile di ambiente ad un processo\footnote{Ogni processo ha la sua lista di variabili che possiamo assegnare.} o direttamente alla shell. Ad esempio, per la console del terminale la variabile di ambiente \verb*|HOME| si può stampare su schermo con il comando:
\begin{verbatim}
	echo $HOME
\end{verbatim}
che darà come risultato
\begin{verbatim}
	/home/nome_utente
\end{verbatim}

Le variabili di ambiente sono molto utili per la creazione di script, in quanto possiamo modificare le cose localmente. Ad esempio è possibile impostare percorsi differenti per librerie diverse. Supponiamo di voler lanciare un codice con alcune librerie su due diverse architetture di processori. Grazie alle variabili di ambiente possiamo configurare le librerie che il nostro codice utilizza prima della compilazione, in questo modo se andiamo a compilare il nostro codice su un'architettura \verb*|arm64| o \verb*|amd64|, non dobbiamo cambiare il codice, ma solamente il percorso delle librerie che saranno differenti per ogni architettura.\\

Molte variabili di ambiente vengono inizializzate quando il sistema operativo viene installato, ad esempio la variabile \verb*|HOME| che abbiamo visto prima, oppure la variabile \verb*|USER|, mentre alcune variabili di ambiente vengono assegnate quando installiamo del software, ad esempio delle librerie grafiche, o il compilatore \verb*|gcc/g++|.\\
Per visualizzare tutte le variabili di ambiente impostate basta utilizzare il comando \verb*|env|. Per crearne una nuova, si utilizza la convenzione di definirle in maiuscolo, ad esempio:
\begin{verbatim}
	export MY_VAR="value"
\end{verbatim}

D'ora in poi la variabile \verb*|MY_VAR| sarà disponibile nei processi figlio. 
\subsection{Vincoli}
Le variabili d'ambiente sono implementate come un array di stringhe\footnote{Ovvero come delle frasi.} secondo le convenzioni del linguaggio C\footnote{\hyperref{https://en.cppreference.com/w/c/language}{docu}{C}{Documentazione linguaggio C.}}, nella forma \verb*|"nome=valore"|: questo implica sia che i nomi non possano contenere il carattere \verb*|"="|, sia che né il nome né il valore possano contenere il carattere \verb*|ASCII 0x00, NUL|. Due nomi sono considerati uguali solo se contengono esattamente gli stessi caratteri, per cui viene ad esempio fatta distinzione tra lettere maiuscole e minuscole.

A parte questi vincoli, la scelta di nomi per variabili d'ambiente è anche fortemente influenzata dai vincoli di sintassi delle shell testuali, che di fatto restringono la scelta a nomi composti da una lettera o un trattino basso (\verb*|"_"|) seguiti da zero o più lettere, cifre e trattini bassi, ad esempio "A", \verb*|"_Alice_12", "file_temporaneo"|. Possono esistere variabili che non seguono queste convenzioni nei nomi, tuttavia ciò ne rende alquanto difficile l'utilizzo pratico.

Non vi sono limiti sulle dimensioni massime ed il numero delle variabili d'ambiente, se non quelli dettati dalla disponibilità di memoria; tuttavia le chiamate di sistema della famiglia \verb*|exec|, che sostituiscono il processo invocante con un altro programma, possono fallire se lo spazio totale occupato delle variabili d'ambiente di un processo, unitamente allo spazio occupato dei parametri per il nuovo programma, supera la dimensione in byte definita della costante \verb*|ARG_MAX| definita nello header file \verb*|limits.h|. Il valore minimo di tale costante per lo standard \verb*|POSIX| è di \verb*|4096 byte|, definito dalla costante \verb*|_POSIX_ARG_MAX|.
\subsection{Moduli di Ambiente}
In un contesto cluster, è molto probabile, data la mole di utenti con differenti esigenze, che siano necessarie diverse versioni dello stesso software. Un esempio è il modulo \verb*|OpenMPI|. Per adattarsi alle differenti esigenze, potrebbe essere necessario utilizzare una o l'altra versione dello stesso compilatore. Per risolvere il problema, si possono costruire più ambienti, dove le variabili assumono valori diversi. Questo viene fatto perché in linea di principio un amministratore del sistema non sa cosa serve all'utente, e quindi è meglio dare la possibilità di caricare diverse versioni dello stesso modulo. Ad esempio:
\begin{verbatim}
	module load openmpi/gcc/64/1.10.3
\end{verbatim}
carica il modulo \verb*|OpenMPI| compilato con \verb*|gcc| per sistemi \verb*|x64| nella versione \verb*|1.10.3|. \\
Ad ogni modulo viene generalmente associato un file di definizione, che può essere uno script \verb*|LUA|\footnote{\hyperref{https://www.lua.org/}{docu}{LUA}{Documentazione LUA}} o \verb*|Tcl|\footnote{\hyperref{https://www.tcl.tk/}{docu}{tcl}{Documentazione Tcl}}.

\section{Esempi di utilizzo nella shell testuale.}
Nelle shell testuali è possibile usare il comando env sia per visualizzare le impostazioni correnti, sia per avviare nuovi programmi con valori particolari delle variabili d'ambiente.

In aggiunta a questo, per le shell derivate dalla Bourne shell come Bash o la Korn shell, il meccanismo delle variabili della shell si sovrappone in parte a quello delle variabili d'ambiente, per cui le variabili d'ambiente sono automaticamente anche variabili della shell, e le variabili della shell possono a loro volta divenire variabili d'ambiente (ad esempio tramite il comando \verb*|"export nome_variabile"|). Ad esempio:

\begin{esempio}
	Script \verb*|bash| di esempio per manipolare le variabili di ambiente.
	\begin{verbatim}
		#!/bin/bash
		
		# PATH è una variabile di ambiente già avvalorata
		# e la si può usare come qualsiasi altra variabile
		# di shell
		echo "$PATH"
		
		# MY_VAR è una variabile di shell che non esisteva in precedenza. 
		# I comandi avviati non ne hanno visibilità, se non passandola 
		# esplicitamente come parametro.
		MY_VAR=123
		echo "$MY_VAR"
		
		# Cerchiamo MY_VAR tra le variabili di 
		# ambiente (non la troveremo).
		env | grep "^MY_VAR="
		
		# Con il comando export è possibile rendere MY_VAR anche una variabile di
		# ambiente, automaticamente visibile ai comandi avviati in seguito. 
		export MY_VAR
		
		# Cerchiamo nuovamente MY_VAR tra le variabili di 
		# ambiente (ora invece la troveremo).
		env | grep "^MY_VAR="
		
		# Le shell più comuni (Bash e Korn shell) permettono
		# di combinare il comando export con una assegnazione,
		# ad esempio con
		export MY_VAR="nuovo valore"
		
		# Attenzione: a differenza di MS-DOS, impostare una variabile di
		# ambiente ad un valore vuoto non la cancella. Essa continua
		# ad esistere, solo che ha un valore vuoto.
		export MY_VAR=
		env | grep "^MY_VAR="
		
		# Per eliminare del tutto una variabile di
		# ambiente occorre usare il comando "unset"
		unset MY_VAR
	\end{verbatim}
\end{esempio}

\section{Variabili di ambiente notevoli}
\subsection{EDITOR e VISUAL}
Queste variabili suggeriscono il comando da usare per avviare un editor di testo per modificare un file di testo.\\
Valori tipici possono essere "vi", "emacsclient" o anche "gedit" 
\subsection{ENV}
Questa variabile indica il nome di uno script di shell da eseguire ad ogni avvio in modalità interattiva della shell, in aggiunta ad altri script eseguiti automaticamente all'avvio in seguito alla procedura di login.\\
Valori tipici possono essere ad esempio \verb*|"~/.bashrc"| o \verb*|"~/.kshrc"|. 
\subsection{HOME}
Normalmente viene avvalorata automaticamente dal sistema con il pathname della home directory dell'utente corrente. 

\subsection{http proxy e ftp proxy}
 Queste variabili indicano quale proxy usare per connessioni HTTP e FTP. Ad esempio, in uno script di shell: 
 \begin{verbatim}
 	# Proxy HTTP che richiede autenticazione
 	http_proxy="http://utente:password@proxy:8080"
 	export http_proxy
 	
 	# Proxy HTTP che non richiede autenticazione
 	http_proxy="http://proxy:8080"
 	export http_proxy
 \end{verbatim}

\subsection{LANG}
Questa variabile specifica le impostazioni locali, come lingua da usare per l'interfaccia utente, convenzioni su formato di data e ora, rappresentazione dei numeri, codifica dei carattere in uso e altro ancora. Viene usata per specificare le impostazioni predefinite di sistema.

I valori possibili per \verb*|LANG| sono quelli elencati dal comando "locale -a", ad esempio \verb*|"it_IT.UTF-8"|, o \verb*|"C"|.

\verb*|LANG| è solo una delle variabili d'ambiente che controllano la localizzazione: ne esistono altre che trattano aspetti specifici (ad esempio \verb*|LC_MONETARY|, \verb*|LC_MESSAGES|, \verb*|LC_NUMERIC|) ed hanno precedenza su \verb*|LANG|. In particolare esiste anche \verb*|LC_ALL| che ha precedenza su tutte le altre (anche su \verb*|LANG|) e che può essere usata per specificare rapidamente l'uso di una localizzazione diversa da quella predefinita. 

\subsection{LD LIBRARY PATH}
Nei sistemi che adottano \verb*|ELF|\footnote{ELF(Executable and Linkable Format) è un formato file standard per eseguibili, codice oggetto, librerie condivise e core dump.} come formato dei file eseguibili, \verb*|LD_LIBRARY_PATH| indica al \verb*|linker| dinamico una serie di directory separate da due punti (\verb*|":"|) in cui cercare librerie software in aggiunta a quelle predefinite nel sistema. 

\subsection{LD PRELOAD}
Nei sistemi che adottano ELF come formato dei file eseguibili, \verb*|LD_PRELOAD| indica al \verb*|linker| dinamico una o più librerie software da precaricare, in aggiunta a quelle richieste dal programma.\\
Questo meccanismo è utile per usare librerie che ridefiniscono l'implementazione di funzioni standard, e che ad esempio possono permettere di accedere in maniera trasparente a file compressi o tenere traccia di tutte le allocazioni di memoria effettuate. 

\subsection{MANPATH}
Specifica una serie di directory separate da due punti ("\verb|:|") in cui cercare delle pagine man, in aggiunta a quelle predefinite nel sistema. 

\subsection{PATH}
Specifica una serie di directory separate da due punti ("\verb*|:|") in cui il sistema ricerca file eseguibili quando essi non sono qualificati con alcuna directory.

Un valore tipico è "\verb*|/bin:/usr/bin:/usr/local/bin|", ma varia da sistema a sistema.

È da sottolineare che per motivi di sicurezza, nei sistemi Unix e Unix-like la directory corrente (rappresentata con un punto ".") non viene automaticamente inclusa tra quelle in cui effettuare la ricerca: se si vuole includerla, occorre specificarla esplicitamente nel valore di \verb*|PATH|. 

\subsection{POSIXLY CORRECT}

Se è definita (il valore non è rilevante), i programmi del progetto \verb*|GNU| si comportano secondo quanto previsto dallo standard \verb*|POSIX| anche nei casi dove normalmente essi divergono dallo standard.\\
Ad esempio, lo standard \verb*|POSIX| prevede che i comandi df e du utilizzino come unità di misura dei blocchi da \verb*|512 byte|, mentre le versioni \verb*|GNU| normalmente utilizzano come unità di misura dei blocchi da un \verb*|KiB|. Impostando la variabile d'ambiente \verb*|POSIXLY_CORRECT| ad un qualunque valore anch'essi useranno blocchi da \verb*|512 byte|.

\subsection{TMPDIR}
Specifica il pathname di una directory da usare per file temporanei. Normalmente non è impostata, in quanto le directory per i file temporanei sono già stabilite per convenzione (ovvero \verb*|/tmp| e \verb*|/var/tmp|), tuttavia è buona norma per i programmi che creano file temporanei di grosse dimensioni prendere in considerazione anche il valore di questa variabile prima di usare direttamente le directory standard.

\subsection{TERM}
Indica il tipo di terminale o terminale virtuale in uso, in modo che i programmi che offrono un'interfaccia a caratteri possano visualizzarla correttamente. Il valore è un identificativo in una base dati fornita dal sistema operativo (\verb*|termcap| o \verb*|terminfo|) che descrive le caratteristiche del terminale e le sequenze di caratteri necessarie a compiere azioni quali ad esempio lo spostamento del cursore o la cancellazione di una linea.\\
Valori tipici sono "\verb*|xterm|" e "\verb*|vt100|"

\subsection{TZ}
Specifica la regola da usare per convertire dalla data di sistema (mantenuta internamente in tempo coordinato universale) nella data e ora locali all'utente, e viceversa. 


\chapter{Informazioni e Configurazione di Sistema}

\section{La cartella /proc}
Come abbiamo visto prima, la cartella \verb*|/proc| contiene tutte le informazioni di sistema sotto forma di files di testo. Tali files non possono essere editati. Possiamo ad esempio vedere quale immagine del sistema viene lanciata all'avvio dal kernel digitando
\begin{verbatim}
	cat /proc/cmdline
\end{verbatim}
che dà come risultato:
\begin{verbatim}
	BOOT_IMAGE=/boot/vmlinuz-linux-lts root=UUID=4dfe8811-d2c8-4fd9-a03e-cea004e15b60 
		rw loglevel=0 quiet splash	
\end{verbatim}
Vediamo che l'immagine di \verb*|BOOT| è un kernel \verb*|lts|\footnote{Long term support: ovvero un kernel che viene aggiornato solo quando si è \textit{sicuri} che i moduli e drivers funzionino sulla maggiorn parte delle macchine. In breve: è più stabile del semplice kernel Linux.}. Questa immagine viene caricata con diverse opzioni:
\begin{itemize}
	\item \verb*|root|=\verb*|UUID...|: indica l'etichetta del disco fisso che contiene la partizione Linux. 
	\item \verb*|rw|: imposta i permessi dell'utente \verb*|root| sulla partizione che contiene Linux.
	\item \verb*|loglevel=0|: questa variabile assume valori interi. Più è alto il numero associato e più il sistema, durante l'avvio, stampa su video informazioni aggiuntive. Tipo i moduli e drivers che vengono caricati, eventuali errori di montaggio di dispositivi interni ed esterni, ecc..
	\item \verb*|quiet splash|: questa opzione sostituisce il log di sistema su video con l'immagine del produttore della nostra macchina.
\end{itemize}
Altri files danno maggiori informazioni, ad esempio:
\begin{itemize}
	\item  \verb*|/proc/apm| : Fornisce informazioni su Advanced Power Management, se è installato.
	\item  \verb*|/proc/acpi|: una directory simile che offre molti dati sulla più moderna \textit{Advanced Configuration and Power Interface}. Ad esempio, per vedere se il laptop è collegato all'alimentazione CA, si può utilizzare  \verb*|cat /proc/acpi/ac_adapter/AC/stateper| ottenere "on line" o "off line". 
	\item \verb*|proc/loadavg|: un file correlato che mostra il carico medio sul processore; le sue informazioni includono l'utilizzo della CPU nell'ultimo minuto, negli ultimi cinque minuti e negli ultimi 10 minuti, nonché il numero di processi attualmente in esecuzione.
	\item \verb*|/proc/stat|: Fornisce anche statistiche, ma risale all'ultimo avvio.
	\item \verb*|/proc/uptime|: un breve file che ha solo due numeri: quanti secondi la nostra sessione è rimasta attiva e quanti secondi è rimasta inattiva.
	\item \verb*|/proc/devices| attualmente configurati e caricati : Visualizza tutti i dispositivi di caratteri e blocchi . 
	\item \verb*|/proc/ide| e \verb*|/proc/scsi|: forniscono dati su dispositivi \verb*|IDE| e \verb*|SCSI|.
	\item \verb*|/proc/ioports| : mostra informazioni sulle regioni utilizzate per la comunicazione \verb*|I/O| con tali dispositivi.
	\item \verb*|/proc/dma| : Mostra i canali Direct Memory Access\footnote{E' quel meccanismo che permette ad altri sottosistemi, quali ad esempio le periferiche, di accedere direttamente alla memoria interna per scambiare dati.} in uso.
	\item \verb*|/proc/filesystems|: mostra quali tipi di filesystem sono supportati dal nostro kernel. Il file è fatto più o meno in questo modo:
	\begin{verbatim}
		nodev sysfs
		nodev rootfs
		nodev bdev
		processo nodev
		nodev cpuset
		...alcune righe tagliate...
		nodev ramfs
		nodev hugetlbfs
		codev nodev
		est3
		nodev usbfs
		ext2
		nodev autofs
	\end{verbatim}

\end{itemize}
\subsection{Informazioni su CPU e RAM}
Vi sono due files in \verb*|/proc| che sono molto utili. Essi ci danno informazioni sulla memoria \verb*|RAM| e sulla \verb*|cpu|. Vediamo cosa contengono.\\
 Ad esempio:
\begin{verbatim}
	cat /proc/cpuinfo
\end{verbatim}
dà come risultato un output simile a questo, ripetuto per ogni \verb*|thread| del processore. 
\begin{verbatim}
	processor	: 0
	vendor_id	: GenuineIntel
	cpu family	: 6
	model		: 141
	model name	: 11th Gen Intel(R) Core(TM) i7-11800H @ 2.30GHz
	stepping	: 1
	microcode	: 0x42
	cpu MHz		: 4600.000
	cache size	: 24576 KB
	physical id	: 0
	siblings	: 16
	core id		: 0
	cpu cores	: 8
	apicid		: 0
	initial apicid	: 0
	fpu		: yes
	fpu_exception	: yes
	cpuid level	: 27
	wp		: yes
\end{verbatim}
dove sono state omesse le flags per questioni di privacy. Mentre per vedere le informazioni riguardanti la memoria possiamo digitare
\begin{verbatim}
	cat /proc/meminfo
\end{verbatim}
che dà come risultato le informazioni riguardanti la memoria \verb*|RAM|:
\begin{verbatim}
	MemTotal:       16079416 kB
	MemFree:         9264608 kB
	MemAvailable:   12265032 kB
	Buffers:          277520 kB
	Cached:          3314440 kB
	SwapCached:            0 kB
	Active:          1179848 kB
	Inactive:        4496328 kB
	Active(anon):      27656 kB
	Inactive(anon):  2540332 kB
	Active(file):    1152192 kB
	Inactive(file):  1955996 kB
	Unevictable:      359052 kB
	Mlocked:              32 kB
	SwapTotal:      17684200 kB
	SwapFree:       17684200 kB
	Dirty:               152 kB
	.
	.
	.
\end{verbatim}

\section{Configurazione della Shell}
\subsection{Il file .bashrc}
Il file .bashrc è un file di script che viene eseguito quando un utente effettua il login. Il file stesso contiene una serie di configurazioni per la sessione del terminale. Ciò include la palette di colori, funzionalità di autocompletamento dei comandi, cronologia della shell, aliases per i comandi e altro. Esso ha una forma di base del tipo:
\begin{verbatim}
	# .bashrc
	
	# Source global definitions
	if [ -f /etc/bashrc ]; then
	. /etc/bashrc
	fi
	
	# User specific environment
	if ! [[ "$PATH" =~ "$HOME/.local/bin:$HOME/bin:" ]]
	then
	PATH="$HOME/.local/bin:$HOME/bin:$PATH"
	fi
	PS1='\u@\h\$'
	
\end{verbatim}
Possiamo editare il file \verb*|.bashrc| aprendolo con un editor di testo, ad esempio
\begin{verbatim}
	vi ~/.bashrc
\end{verbatim}

Possiamo implementare delle funzioni all'interno di questo file. Ad esempio, se vogliamo stampare più informazioni sulla data del semplice comando \verb*|date|, possiamo aggiungere alla fine del file una funzione \verb*|today()|:
\begin{verbatim}
	today()
	{
		echo Oggi è `date +"%A %d di %B dell'anno %Y (%r)"` return
	}
\end{verbatim}
In questo modo \verb*|today| diventerà come un comando per la nostra console. Per rendere effettive le modifiche al file \verb*|.bashrc| dobbiamo caricare di nuovo il file nella nostra console digitando:
\begin{verbatim}
	source ~/.bashrc
\end{verbatim}
Una funzione molto utile è la seguente. Di solito, quando creiamo una nuova cartella con \verb*|mkdir| poi vogliamo spostarci all'interno di essa. Per automatizzare questo processo possiamo creare una nuova funzione:
\begin{verbatim}
	mkcd ()
	{
		mkdir -p -- "$1" && cd -P -- "$1"
	}
\end{verbatim}
Vediamo che in questo caso la modifica comporta dei cambianti sostanziali. Le opzioni \verb*|"$1"| indicano il parametro che digitiamo subito dopo il nuovo comando \verb*|mkcd|. Questo parametro sarà ovviamente il nome della cartella che stiamo creando e nella quale ci sposteremo. 


\chapter{Connessioni SSH}
Secure SHell (\verb*|ssh|) è un protocollo che permette di stabilire una sessione remota cifrata tramite interfaccia a riga di comando con un altro \verb*|host| di una rete informatica. SSH è diventato uno standard di fatto per l'amministrazione remota di sistemi UNIX e di dispositivi di rete, rendendo obsoleto il protocollo telnet, giudicato troppo pericoloso per la sua mancanza di protezione contro le intercettazioni.\\
Il client ed il server SSH sono installati o installabili su molte versioni di UNIX, GNU/Linux, macOS e Microsoft Windows. Inoltre è disponibile come strumento di amministrazione su alcuni apparati di rete. La \verb*|IANA| (Internet Assigned Numbers Authority) ha assegnato al servizio \verb*|SSH| la porta 22 \verb*|TCP|\footnote{Transmission Control Protocol: è un protocollo di rete a pacchetto di livello di trasporto, appartenente alla suite di protocolli Internet, che si occupa di controllo della trasmissione ovvero rendere affidabile la comunicazione dati in rete tra mittente e destinatario.} e \verb*|UDP|\footnote{Lo User Datagram Protocol (UDP), è uno dei principali protocolli di rete della suite di protocolli Internet. È un protocollo di livello di trasporto a pacchetto.}(A differenza del TCP, l'UDP è un protocollo di tipo connectionless, inoltre non gestisce il riordinamento dei pacchetti né la ritrasmissione di quelli persi, ed è perciò generalmente considerato di minore affidabilità), anche se è comunque possibile implementare il servizio SSH su altre porte non definite dalla IANA.

Il comando su sistemi UNIX-like è il seguente: 
\begin{verbatim}
	ssh [opzioni] nomeutente@host [comando]
\end{verbatim}

Nei clusters, l'accesso avviene di solito attraverso \verb*|ssh|, che viene generalmente fornito dal software OpenSSH. Quest'ultimo è preinstallato di default in molte distribuzioni Linux. Prima di effettuare il login, verrà chiesta la password. Questo passaggio può essere bypassato impostando una chiave pubblica o privata, oppure nel caso in cui ci colleghiamo da un client Linux, possiamo installare il pacchetto \verb*|sshpass|, che ci consente di automatizzare il login nel server. La sintassi è:
\begin{verbatim}
	sshpass -p 'password' ssh nomeutente@host
\end{verbatim}

Una volta effettuato il login, avremo a disposizione la console del server. Possiamo anche avviare l'interfaccia grafica \verb*|Xorg|, e quindi un gestore delle finestre (\verb*|wm|) o un ambiente desktop (\verb*|DE|) se essi sono stati installati preventivamente, aggiungendo l'opzione \verb*|-X| al comando \verb*|ssh|. OpenSSH supporta la connessione multipla. Ovvero, se su una rete vi sono più servers possiamo collegarci a tutti i server contemporaneamente su diverse finestre del terminale. Possiamo anche collegarci con più account sullo stesso server, ovviamente. \\
Tutti i files di configurazione si trovano nella cartella \verb*|.ssh|. Essi si possono editare, con un po' di accortezza. 



\end{document}